import { locales } from "@/i18n.config";
import fs from "fs";
import path from "path";
import { DatedProjectMetadata } from "@/types/project.types";
import {
  getMetadataFromFile,
  generateHash,
  getContentSubdirectories,
} from "../utils/index.utils";

type PreviousIndex = Record<string, Partial<DatedProjectMetadata>>;

function generateProjectIndex(
  locale: string,
  previousIndex: PreviousIndex = {}
): DatedProjectMetadata[] {
  const projectDir = path.join(
    process.cwd(),
    `content/${locale}/project`
  );
  if (!fs.existsSync(projectDir)) {
    console.error(`Directory not found: ${projectDir}`);
    return [];
  }

  const subdirectories = getContentSubdirectories(projectDir);

  return subdirectories
    .map((subdir) => {
      const pagePath = path.join(projectDir, subdir, "page.mdx");
      console.log(`Processing page: ${pagePath}`);
      if (fs.existsSync(pagePath)) {
        const metadata = getMetadataFromFile(pagePath);
        if (metadata) {
          const hash = generateHash(metadata);
          const previousEntry = previousIndex[metadata.id] || {};
          const lastUpdated =
            hash !== previousEntry.hash
              ? new Date().toISOString().split("T")[0]
              : previousEntry.last_updated ||
              new Date().toISOString().split("T")[0];

          return {
            id: metadata.id,
            title: metadata.title,
            description: metadata.description,
            accronym: metadata.accronym,
            status: metadata.status,
            img: metadata.img,
            img_alt: metadata.img_alt,
            complexity_score: metadata.complexity_score,
            effort_score: metadata.effort_score,
            adoption_score: metadata.adoption_score,
            blockchain_score: metadata.blockchain_score,
            revenue_score: metadata.revenue_score,
            industry_tags: metadata.industry_tags,
            keyword_tags: metadata.keyword_tags,
            hash,
            last_updated: lastUpdated,
          };
        }
      }
      return null;
    })
    .filter(
      (project): project is DatedProjectMetadata =>
        project !== null && project.id !== undefined
    );
}

console.log("Starting project index generation...");

locales.forEach((locale) => {
  console.log(`Processing locale: ${locale}...`);

  const previousIndexPath = path.join(
    process.cwd(),
    `app/${locale}/project/projects.i18n.ts`
  );

  let previousIndex: PreviousIndex = {};
  if (fs.existsSync(previousIndexPath)) {
    console.log(`Found previous index file for locale: ${locale}`);
    try {
      const previousContent = JSON.parse(
        fs.readFileSync(previousIndexPath, "utf-8")
      );
      previousIndex = (previousContent[locale] || []).reduce(
        (acc: PreviousIndex, project: DatedProjectMetadata) => {
          acc[project.id] = project;
          return acc;
        },
        {}
      );
    } catch (error) {
      console.error(
        `Failed to load previous index for locale ${locale}...`,
        error
      );
    }
  }

  console.log(`Generating project index for locale: ${locale}`);
  const projectIndex = generateProjectIndex(locale, previousIndex);

  // Write to content/${locale}/project/index.ts
  const outputFilePath = path.join(
    process.cwd(),
    `content/${locale}/project/index.ts`
  );
  const fileContent = `// This file is generated by project-index.script.ts. Do not edit manually.\nimport { DatedProjectMetadata } from \"@/types/project.types\";\n\nconst data: DatedProjectMetadata[] = ${JSON.stringify(
    projectIndex,
    null,
    2
  )};\n\nexport default data;\n`;
  console.log(`Writing output file to: ${outputFilePath}`);
  fs.writeFileSync(outputFilePath, fileContent);
});

console.log("Project index generation completed.");
